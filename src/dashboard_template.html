<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Model Performance Simulator</title>
    <style>
        /* ==========================================================================
           1. Root Variables & Global Styles
           ========================================================================== */
        :root {
            --bg-color: #f4f7f9;
            --panel-bg: #ffffff;
            --border-color: #dee2e6;
            --text-color: #212529;
            --header-color: #005a9c;
            --slider-color: #007bff;
            --correct-text-color: #28a745;
            --manual-text-color: #6c757d;
            --error-text-color: #dc3545;
            --cell-bg: #ffffff;
            --cell-empty-bg: #f8f9fa;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 1.5rem;
        }

        /* ==========================================================================
           2. Layout & Panels
           ========================================================================== */
        main { max-width: 1400px; margin: auto; }
        .main-container { display: flex; gap: 1.5rem; margin-top: 1.5rem; }
        .panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .controls-panel { flex: 1; min-width: 350px; }
        .outputs-panel { flex: 2; }

        /* Top panel containing scenario description and reference stats */
        .top-panel-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 2rem;
            margin-top: 1rem;
        }
        .scenario-description { flex: 1; }
        .scenario-description > p { margin-top: 0; margin-bottom: 0.5rem; }
        .scenario-description > ul { margin-top: 0; padding-left: 1.5rem; font-size: 0.9rem; }

        /* ==========================================================================
           3. Typography
           ========================================================================== */
        h1, h2 {
            color: var(--header-color);
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        h2 { font-size: 1.2rem; margin-top: 2rem; }
        header > h1 { margin-bottom: 0; }

        /* ==========================================================================
           4. Components
           ========================================================================== */

        /* --- Model Performance Reference Box --- */
        .model-performance-box {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 1rem;
            min-width: 320px;
        }
        .model-performance-box .label {
            font-size: 0.9rem;
            color: #6c757d;
            font-weight: 600;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .ref-stat-container { display: flex; justify-content: space-around; align-items: center; }
        .ref-stat { text-align: center; }
        .ref-stat .ref-label { font-size: 0.8rem; color: #6c757d; display: block; }
        .ref-stat .ref-value { font-size: 1.25rem; font-weight: 600; color: var(--header-color); }

        /* --- Sliders --- */
        .slider-group { margin-bottom: 1rem; }
        .slider-group label { display: block; font-weight: 600; margin-bottom: 0.5rem; }
        .slider-group input[type="range"] { width: 100%; cursor: pointer; margin-top: 0.5rem; }
        .slider-labels { display: flex; justify-content: space-between; font-size: 0.8rem; color: #6c757d; }
        .ruler { display: flex; justify-content: space-between; font-size: 0.75rem; color: #6c757d; padding: 0 2px; margin-bottom: 1.5rem; }
        .slider-value { font-weight: bold; color: var(--slider-color); }

        /* --- Summary Stat Grid --- */
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.5rem; }
        .stat-box { padding: 1rem; border-radius: 5px; background-color: var(--bg-color); }
        .stat-box .label { font-size: 0.9rem; color: #6c757d; }
        .stat-box .value { font-size: 1.75rem; font-weight: bold; color: var(--header-color); }
        .stat-box .sub-value { font-size: 0.8rem; }

        /* --- Confusion Matrix --- */
        .matrix-container { margin-top: 1rem; font-size: 0.85rem; }
        .confusion-matrix { width: 100%; border-collapse: collapse; text-align: center; table-layout: fixed; }
        .confusion-matrix th, .confusion-matrix td { border: 1px solid var(--border-color); padding: 0.25rem; height: 70px; }
        .confusion-matrix thead th { height: auto; padding: 0.3rem; font-size: 0.8rem; font-weight: 600; }
        .confusion-matrix th { background-color: #e9ecef; font-weight: 600; }
        .confusion-matrix .axis-label { font-weight: bold; writing-mode: vertical-rl; transform: rotate(180deg); text-align: center; padding: 1rem 0.25rem; width: 20px; }
        .confusion-matrix .header-label { padding: 0.5rem 1rem; }
        .confusion-matrix td { font-size: 1.1rem; font-weight: 600; cursor: default; background-color: var(--cell-bg); }
        .cm-cell-content { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; }
        .cm-automated-correct { color: var(--correct-text-color); }
        .cm-automated-error { color: var(--error-text-color); }
        .cm-manual-count { color: var(--manual-text-color); }
        .cm-empty .cm-automated-correct, .cm-empty .cm-automated-error, .cm-empty .cm-manual-count { color: #adb5bd; }
        .cm-critical { box-shadow: inset 0 0 0 3px var(--error-text-color); }
        .matrix-legend { display: flex; justify-content: center; flex-wrap: wrap; gap: 1.5rem; margin-top: 1.5rem; }
        .legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .legend-item .label-correct { font-weight: bold; color: var(--correct-text-color); }
        .legend-item .label-error { font-weight: bold; color: var(--error-text-color); }
        .legend-item .label-manual { font-weight: bold; color: var(--manual-text-color); }
        .legend-item .critical-box { display:inline-block; width: 15px; height: 15px; border: 3px solid var(--error-text-color); }

        /* --- Explanation Box --- */
        .chart-explanation {
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 0.75rem;
            background-color: var(--bg-color);
            padding: 1rem;
            border-radius: 5px;
        }
        .chart-explanation > p { margin-top:0; margin-bottom:0.75rem; font-weight: bold; }
        .chart-explanation ul { margin: 0; padding-left: 1.25rem; text-align: left; }
        .chart-explanation li { margin-bottom: 0.5rem; }
        .chart-explanation li:last-child { margin-bottom: 0; }
        .chart-explanation ul ul { padding-left: 1.25rem; margin-top: 0.5rem; } /* Nested lists */
        .chart-explanation .highlight-correct { color: var(--correct-text-color); font-weight: bold; }
        .chart-explanation .highlight-error { color: var(--error-text-color); font-weight: bold; }

    </style>
</head>
<body>

<!-- Using <main> as the primary content wrapper for semantic structure -->
<main>

    <!-- SECTION: Scenario Definition. This section provides context for the tool. -->
    <section class="panel">
        <header>
            <h1>Scenario: Business Automation</h1>
        </header>
        <div class="top-panel-content">
            <div class="scenario-description">
                <p>This dashboard simulates an automation workflow for classifying wine scores.</p>
                <ul>
                    <li>When a new item is encountered, the model provides a predicted class and a confidence score.</li>
                    <li>If the model's confidence exceeds the user-set threshold for the predicted class, the classification is <strong>automated</strong> (e.g. item sent directly to billing).</li>
                    <li>If the model's confidence is below the threshold, the item is sent for <strong>manual review</strong>.</li>
                </ul>
            </div>
            <div class="model-performance-box">
                <div class="label">Model Performance (v0.2 Reference)</div>
                <div class="ref-stat-container">
                    <div class="ref-stat">
                        <span class="ref-label">Accuracy</span>
                        <span class="ref-value">66.0%</span>
                    </div>
                    <div class="ref-stat">
                        <span class="ref-label">F1-Score (wgt)</span>
                        <span class="ref-value">0.64</span>
                    </div>
                    <div class="ref-stat">
                        <span class="ref-label">Test Set</span>
                        <span class="ref-value">480</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <div class="main-container">

        <!-- SECTION: Controls. User interaction elements are grouped here. -->
        <section class="panel controls-panel">
            <h1>Controls</h1>
            <p>Set the confidence required to automate a case for each **predicted** wine quality score.</p>
            <div id="sliders-container">
                <!-- Sliders are dynamically generated by JavaScript -->
            </div>
        </section>

        <!-- SECTION: Outputs. All simulation results are displayed here. -->
        <section class="panel outputs-panel">
            <h1>Impact & Outcomes</h1>

            <!-- High-level summary metrics -->
            <div class="summary-grid">
                <div class="stat-box"><div class="label">Total Automation Rate</div><div class="value"><span id="total-automation-rate">...</span>%</div><div class="sub-value">(<span id="total-automated-count">...</span> of <span id="total-cases-count">...</span> total cases)</div></div>
                <div class="stat-box"><div class="label">Manual Review Workload</div><div class="value"><span id="manual-review-count">...</span></div><div class="sub-value">(Cases requiring human review)</div></div>
                <div class="stat-box"><div class="label">Automation Accuracy</div><div class="value"><span id="overall-accuracy">...</span>%</div><div class="sub-value">(Of <span id="accuracy-automated-count">...</span> automated cases)</div></div>
            </div>

            <h2>Per-Class Performance Matrix</h2>
            <figure class="matrix-container" id="matrix-container" aria-labelledby="matrix-caption">
                <!-- Matrix table is dynamically generated by JavaScript -->
            </figure>
            <figcaption class="matrix-legend">
                <div class="legend-item"><span class="label-correct">0</span><span>: Correctly Automated</span></div>
                <div class="legend-item"><span class="label-error">0</span><span>: Automation Error</span></div>
                <div class="legend-item"><span class="label-manual">0</span><span>: Sent to Manual Review</span></div>
                <div class="legend-item"><span class="critical-box"></span><span>Critical Error Type</span></div>
            </figcaption>

            <div class="chart-explanation">
                <p id="matrix-caption">How to read this matrix:</p>
                <ul>
                    <li><strong>Rows</strong> represent the item's actual, true class.</li>
                    <li><strong>Columns</strong> represent the class the model predicted.</li>
                    <li>Each cell contains two counts:
                        <ul>
                            <li><strong>Top Number:</strong> Cases <strong>automated</strong> by the system.</li>
                            <li><strong>Bottom Number:</strong> Cases sent to <strong>manual review</strong>.</li>
                        </ul>
                    </li>
                    <li>The color of the top <strong>Automated</strong> number indicates its outcome:
                        <ul>
                            <li><span class="highlight-correct">Green:</span> Correctly automated (found on the diagonal).</li>
                            <li><span class="highlight-error">Red:</span> An automation error (found off the diagonal).</li>
                        </ul>
                    </li>
                    <li>The decision to automate is driven by the threshold you set for the <strong>predicted class (the column)</strong>. Lowering a threshold causes counts in its column to <strong>shift</strong> from the bottom number (manual) to the top number (automated), revealing the direct trade-off of your choice.</li>
                    <li>In this example, we can automate about a quarter of the cases, if we're happy with 90% automation accuracy.</li>
                </ul>
            </div>
        </section>

    </div>
</main>

<script>
// This is the placeholder for our data.
// Security consideration: Data injected this way must be properly escaped/sanitized on the server
// to prevent XSS if it contains user-generated content. In this application, the data is assumed to be safe.
const INJECTED_MODEL_DATA = {{JSON_PAYLOAD}};

document.addEventListener('DOMContentLoaded', () => {

    /**
     * =================================================================================
     * ARCHITECTURE OVERVIEW
     * =================================================================================
     * This application is structured into three main conceptual parts for clarity
     * and separation of concerns:
     *
     * 1. State: A "single source of truth" object that holds all the application's
     *    dynamic data, like current thresholds and calculated metrics.
     *
     * 2. UI: An object that handles ALL interactions with the DOM. It builds the
     *    initial HTML, reads user input, and renders the State to the screen. It
     *    doesn't know how the data is calculated, only how to display it.
     *
     * 3. App: The main controller. It initializes the application, contains the
     *    core simulation logic, and orchestrates the flow of data between the
     *    State and the UI.
     * =================================================================================
     */

    const CONSTANTS = {
        CLASS_NAMES: INJECTED_MODEL_DATA.class_names,
        TEST_CASES: INJECTED_MODEL_DATA.test_cases,
        // Business logic defining what constitutes a critical error.
        IS_CRITICAL_ERROR: (trueClass, predictedClass) => parseInt(trueClass, 10) >= 7 && parseInt(predictedClass, 10) <= 5
    };

    const State = { thresholds: {}, metrics: {} };

    const UI = {
        elements: {
            slidersContainer: document.getElementById('sliders-container'),
            matrixContainer: document.getElementById('matrix-container'),
            totalAutomationRate: document.getElementById('total-automation-rate'),
            totalAutomatedCount: document.getElementById('total-automated-count'),
            totalCasesCount: document.getElementById('total-cases-count'),
            manualReviewCount: document.getElementById('manual-review-count'),
            overallAccuracy: document.getElementById('overall-accuracy'),
            accuracyAutomatedCount: document.getElementById('accuracy-automated-count'),
        },

        buildDynamicElements() {
            // Build Sliders: Create one slider for each class name provided in the data.
            CONSTANTS.CLASS_NAMES.forEach(name => {
                const sliderGroup = document.createElement('div');
                sliderGroup.className = 'slider-group';
                sliderGroup.innerHTML = `
                    <label for="slider-${name}">Class ${name}: <span class="slider-value" id="slider-value-${name}">95</span>%</label>
                    <div class="slider-labels"><span>More Auto</span><span>More Cautious</span></div>
                    <input type="range" min="50" max="100" value="95" class="slider" id="slider-${name}" data-class-name="${name}">
                    <div class="ruler"><span>50</span><span>60</span><span>70</span><span>80</span><span>90</span><span>100</span></div>`;
                this.elements.slidersContainer.appendChild(sliderGroup);
            });
            this.elements.totalCasesCount.textContent = CONSTANTS.TEST_CASES.length;

            // Build Confusion Matrix Structure: Generate the table shell (headers and empty cells).
            let tableHTML = '<table class="confusion-matrix"><thead><tr><th class="axis-label" rowspan="2">True Class</th><th class="header-label" colspan="' + CONSTANTS.CLASS_NAMES.length + '">Predicted Class</th></tr><tr>';
            CONSTANTS.CLASS_NAMES.forEach(name => { tableHTML += `<th>${name}</th>`; });
            tableHTML += '</tr></thead><tbody>';
            CONSTANTS.CLASS_NAMES.forEach(trueName => {
                tableHTML += `<tr><th>${trueName}</th>`;
                CONSTANTS.CLASS_NAMES.forEach(predName => {
                    tableHTML += `<td id="cell-${trueName}-${predName}"></td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';
            this.elements.matrixContainer.innerHTML = tableHTML;
        },

        getThresholds() {
            const thresholds = {};
            document.querySelectorAll('.slider').forEach(slider => {
                thresholds[slider.dataset.className] = slider.value / 100;
            });
            return thresholds;
        },

        render(state) {
            this.renderSliderValues(state.thresholds);
            this.renderSummaryMetrics(state.metrics.summary);
            this.renderMatrix(state.metrics.matrix);
        },

        renderSliderValues(thresholds) {
            for (const [className, threshold] of Object.entries(thresholds)) {
                document.getElementById(`slider-value-${className}`).textContent = Math.round(threshold * 100);
            }
        },

        renderSummaryMetrics(summary) {
            this.elements.totalAutomationRate.textContent = summary.automationRate.toFixed(1);
            this.elements.totalAutomatedCount.textContent = summary.totalAutomated;
            this.elements.manualReviewCount.textContent = summary.manualReview;
            this.elements.overallAccuracy.textContent = summary.automationAccuracy.toFixed(1);
            this.elements.accuracyAutomatedCount.textContent = summary.totalAutomated;
        },

        renderMatrix(matrix) {
            CONSTANTS.CLASS_NAMES.forEach(trueClass => {
                CONSTANTS.CLASS_NAMES.forEach(predictedClass => {
                    // 1. Get the data for the current cell (e.g., True=5, Predicted=6)
                    const cellData = matrix[trueClass][predictedClass];
                    const cellElement = document.getElementById(`cell-${trueClass}-${predictedClass}`);

                    // 2. Calculate automated and manual counts
                    const automatedCount = cellData.correct + cellData.error;
                    const manualCount = cellData.manual;

                    // 3. Determine the class and content for the 'automated' number
                    let automatedContent = automatedCount;
                    let automatedClass = '';
                    if (trueClass === predictedClass) { // On the diagonal -> correct automation
                        automatedClass = 'cm-automated-correct';
                    } else { // Off the diagonal -> automation error
                        automatedClass = 'cm-automated-error';
                        if (automatedCount === 0) { automatedContent = '-'; } // Use dash for zero errors for readability
                    }

                    // 4. Build and inject the cell's HTML
                    cellElement.innerHTML = `
                        <div class="cm-cell-content">
                            <span class="${automatedClass}">${automatedContent}</span>
                            <span class="cm-manual-count">${manualCount}</span>
                        </div>
                    `;

                    // 5. Apply special styling classes for critical errors or empty cells
                    cellElement.classList.toggle('cm-critical', CONSTANTS.IS_CRITICAL_ERROR(trueClass, predictedClass));
                    cellElement.classList.toggle('cm-empty', automatedCount === 0 && manualCount === 0);

                    // 6. Set a tooltip for detailed information
                    cellElement.title = `True: ${trueClass}, Predicted: ${predictedClass}\nAutomated: ${automatedCount}\nManual: ${manualCount}`;
                });
            });
        }
    };

    const App = {
        init() {
            UI.buildDynamicElements();
            // Performance consideration: For large datasets, this event handler could be "debounced"
            // to prevent re-running the simulation on every single pixel of slider movement.
            UI.elements.slidersContainer.addEventListener('input', this.handleSliderChange.bind(this));
            this.runFullUpdate();
        },

        handleSliderChange() {
            this.runFullUpdate();
        },

        runFullUpdate() {
            State.thresholds = UI.getThresholds();
            State.metrics = this.runSimulation(State.thresholds, CONSTANTS.TEST_CASES);
            UI.render(State);
        },

        runSimulation(thresholds, testCases) {
            // 1. Initialize a nested object to hold all metrics.
            const metrics = {
                summary: { totalAutomated: 0, totalCorrect: 0, criticalErrors: 0 },
                matrix: {}
            };
            CONSTANTS.CLASS_NAMES.forEach(trueName => {
                metrics.matrix[trueName] = {};
                CONSTANTS.CLASS_NAMES.forEach(predName => {
                    metrics.matrix[trueName][predName] = { total: 0, correct: 0, error: 0, manual: 0 };
                });
            });

            // 2. Process each test case against the current thresholds.
            for (const caseData of testCases) {
                const { true_class, scores } = caseData;

                // Find the model's prediction (the class with the highest score).
                let maxScore = -1, predictedClassIndex = -1;
                for (let i = 0; i < scores.length; i++) {
                    if (scores[i] > maxScore) { maxScore = scores[i]; predictedClassIndex = i; }
                }
                const predictedClass = CONSTANTS.CLASS_NAMES[predictedClassIndex];

                // 3. Make the core decision: Automate or send to manual review.
                const requiredThreshold = thresholds[predictedClass];
                const matrixCell = metrics.matrix[true_class][predictedClass];
                matrixCell.total++;

                if (maxScore >= requiredThreshold) {
                    // Case is AUTOMATED
                    metrics.summary.totalAutomated++;
                    if (predictedClass === true_class) {
                        // Correct automation
                        metrics.summary.totalCorrect++;
                        matrixCell.correct++;
                    } else {
                        // Automation error
                        matrixCell.error++;
                        if (CONSTANTS.IS_CRITICAL_ERROR(true_class, predictedClass)) {
                            metrics.summary.criticalErrors++;
                        }
                    }
                } else {
                    // Case is sent to MANUAL review
                    matrixCell.manual++;
                }
            }

            // 4. Calculate final summary statistics based on the processed cases.
            const totalCases = testCases.length;
            metrics.summary.manualReview = totalCases - metrics.summary.totalAutomated;
            metrics.summary.automationRate = totalCases > 0 ? (metrics.summary.totalAutomated / totalCases) * 100 : 0;
            metrics.summary.automationAccuracy = metrics.summary.totalAutomated > 0 ? (metrics.summary.totalCorrect / metrics.summary.totalAutomated) * 100 : 0;

            return metrics;
        }
    };

    App.init();
});
</script>

</body>
</html>